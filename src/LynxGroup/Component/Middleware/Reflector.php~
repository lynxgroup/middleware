<?php namespace Container;

abstract class Reflector extends \ReflectionClass implements \Container\IReflector
{
	protected $args;

	protected $callback;

	protected $instance;

	public function __construct($name, $args = null, callable $callback = null)
	{
		parent::__construct($name);

		$this->args = $args;

		$this->callback = $callback;
	}

	protected function getArgs(array $args = [])
	{
		return array_merge(is_callable($this->args) ? call_user_func($this->args) : (
			is_array($this->args) ? $this->args : []
		), $args);
	}

	protected function resolveArgs(array $parameters, array $args = [])
	{
		$_args = [];

		foreach( $parameters as $parameter )
		{
			$_args[$parameter->getName()] = isset($args[$parameter->getName()]) ? $args[$parameter->getName()] : (
				$parameter->isDefaultValueAvailable() ? $parameter->getDefaultValue() : null
			);
		}

		return $_args;
	}

	public function factory(array $args = [])
	{
		if( $this->getConstructor() )
		{
			$instance = $this->newInstanceArgs(
				$this->resolveArgs($this->getConstructor()->getParameters(), $this->getArgs($args))
			);
		}
		else
		{
			$instance = $this->newInstance();
		}

		if( $this->callback )
		{
			call_user_func($this->callback, $instance);
		}

		return $instance;
	}

	public function singleton(array $args = [])
	{
		if( !$this->instance )
		{
			$this->instance = $this->factory($args);
		}

		return $this->instance;
	}

	public function invoke_method($instance, $method, array $args = [])
	{
		return $this->getMethod($method)->invokeArgs($instance, $this->resolveArgs(
			$this->getMethod($method)->getParameters(), $args)
		);
	}
}
